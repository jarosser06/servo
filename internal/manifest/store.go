package manifest

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"

	"github.com/servo/servo/internal/mcp"
	"github.com/servo/servo/internal/utils"
	"github.com/servo/servo/pkg"
)

// Store handles manifest storage and retrieval for sessions
type Store struct {
	sessionDir string
	parser     *mcp.Parser
}

// NewStore creates a new manifest store for the given session directory
func NewStore(sessionDir string, parser *mcp.Parser) *Store {
	return &Store{
		sessionDir: sessionDir,
		parser:     parser,
	}
}

// StoreManifest stores a parsed .servo manifest for a server
func (s *Store) StoreManifest(serverName, source string) error {
	// Create manifests directory
	manifestDir := filepath.Join(s.sessionDir, "manifests")
	if err := utils.EnsureDirectoryStructure([]string{manifestDir}); err != nil {
		return fmt.Errorf("failed to create manifests directory: %w", err)
	}

	// Parse the source to get the manifest
	var manifest *pkg.ServoDefinition
	var err error

	switch {
	case strings.HasPrefix(source, "http://") || strings.HasPrefix(source, "https://"):
		manifest, err = s.parser.ParseFromURL(source)
	case strings.Contains(source, "@") || strings.Contains(source, "git"):
		// Git repository
		manifest, err = s.parser.ParseFromGitRepo(source, "")
	default:
		// Local file
		manifest, err = s.parser.ParseFromFile(source)
	}

	if err != nil {
		return fmt.Errorf("failed to parse source %s: %w", source, err)
	}

	// Store the manifest with source metadata
	manifestFile := filepath.Join(manifestDir, serverName+".servo")
	return s.writeManifest(manifestFile, manifest, source)
}

// GetManifest retrieves a stored manifest by server name
func (s *Store) GetManifest(serverName string) (*pkg.ServoDefinition, error) {
	manifestFile := filepath.Join(s.sessionDir, "manifests", serverName+".servo")

	if _, err := os.Stat(manifestFile); os.IsNotExist(err) {
		return nil, fmt.Errorf("manifest for server %s not found", serverName)
	}

	return s.parser.ParseFromFile(manifestFile)
}

// ListManifests returns all stored manifests
func (s *Store) ListManifests() (map[string]*pkg.ServoDefinition, error) {
	manifestDir := filepath.Join(s.sessionDir, "manifests")

	if _, err := os.Stat(manifestDir); os.IsNotExist(err) {
		return make(map[string]*pkg.ServoDefinition), nil
	}

	entries, err := os.ReadDir(manifestDir)
	if err != nil {
		return nil, fmt.Errorf("failed to read manifests directory: %w", err)
	}

	manifests := make(map[string]*pkg.ServoDefinition)

	for _, entry := range entries {
		if !strings.HasSuffix(entry.Name(), ".servo") {
			continue
		}

		serverName := strings.TrimSuffix(entry.Name(), ".servo")
		manifest, err := s.GetManifest(serverName)
		if err != nil || manifest == nil {
			// Skip invalid or nil manifests but continue processing others
			continue
		}

		manifests[serverName] = manifest
	}

	return manifests, nil
}

// RemoveManifest removes a stored manifest
func (s *Store) RemoveManifest(serverName string) error {
	manifestFile := filepath.Join(s.sessionDir, "manifests", serverName+".servo")

	if err := os.Remove(manifestFile); err != nil && !os.IsNotExist(err) {
		return fmt.Errorf("failed to remove manifest for %s: %w", serverName, err)
	}

	return nil
}

// writeManifest writes a manifest to disk in .servo format
func (s *Store) writeManifest(filePath string, manifest *pkg.ServoDefinition, source string) error {
	// Add source metadata as comment at top
	content := fmt.Sprintf("# Servo Manifest\n# Source: %s\n# Generated by servo install command\n\n", source)

	// Convert manifest back to YAML format
	yamlContent, err := manifest.ToYAML()
	if err != nil {
		return fmt.Errorf("failed to convert manifest to YAML: %w", err)
	}

	content += yamlContent

	return utils.WriteFileWithDir(filePath, []byte(content), 0644)
}
